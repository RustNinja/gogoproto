package benchmany_test

import (
	"bytes"
	"compress/gzip"
	_ "embed"
	"encoding/json"
	"fmt"
	"strconv"
	"testing"

	"github.com/cosmos/gogoproto/proto"
	"github.com/jhump/protoreflect/desc"
	"github.com/jhump/protoreflect/desc/builder"
	protov2 "google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protodesc"
	"google.golang.org/protobuf/reflect/protoregistry"
	"google.golang.org/protobuf/types/descriptorpb"
)

// Generated by manually marshalling from simd:
// 	bz, err := json.Marshal(proto.AllFileDescriptors())
//	if err != nil {
//		panic(err)
//	}
//	if err := os.WriteFile("/tmp/allfd.json", bz, 0600); err != nil {
//		panic(err)
//	}
//
//go:embed testdata/simd-allfd-c4489d.json
var simdAllFDs_c4489d []byte

// Generated by manually marshalling from simd:
// 	var m []*descriptorpb.FileDescriptorProto
//	protoregistry.GlobalFiles.RangeFiles(func(fd protoreflect.FileDescriptor) bool {
//		m = append(m, protodesc.ToFileDescriptorProto(fd))
//		return true
//	})
//
//	bz, err := json.Marshal(m)
//	if err != nil {
//		panic(err)
//	}
//	if err := os.WriteFile("/tmp/globalfd.json", bz, 0600); err != nil {
//		panic(err)
//	}
//go:embed testdata/simd-globalfd-c4489d.json
var simdGlobalFDs_c4489d []byte

// This benchmark creates dynamic file descriptors so that we can quantify performance
// of larger FD sets.
//
// Importing jhump/protoreflect brings in default google types,
// which breaks the primary mergedregistry tests;
// hence the standalone package.
func BenchmarkMergedFileDescriptors(b *testing.B) {
	var allFDs map[string][]byte
	if err := json.Unmarshal(simdAllFDs_c4489d, &allFDs); err != nil {
		b.Fatal(err)
	}

	var globalFDs []*descriptorpb.FileDescriptorProto
	if err := json.Unmarshal(simdGlobalFDs_c4489d, &globalFDs); err != nil {
		b.Fatal(err)
	}

	gf := new(protoregistry.Files)
	if false {
		// TODO: figure out how to properly deserialize the global FDs.
		for _, fd := range globalFDs {
			f, err := protodesc.NewFile(fd, gf)
			if err != nil {
				panic(err)
			}
			gf.RegisterFile(f)
		}
	}

	wantSize := len(globalFDs) + len(allFDs)
	wantSize = len(allFDs) // TODO: don't reassign here.

	b.ResetTimer()

	b.Run("sequential", func(b *testing.B) {
		b.ReportAllocs()

		for i := 0; i < b.N; i++ {
			fds, err := proto.MergedFileDescriptors(gf, allFDs)
			if err != nil {
				b.Fatal(err)
			}

			if len(fds.File) != wantSize {
				b.Fatalf("expected %d FDs, got %d", wantSize, len(fds.File))
			}
		}
	})

	b.Run("concurrent", func(b *testing.B) {
		b.ReportAllocs()

		for i := 0; i < b.N; i++ {
			fds, err := proto.ConcurrentMergedFileDescriptors(gf, allFDs)
			if err != nil {
				b.Fatal(err)
			}

			if len(fds.File) != wantSize {
				b.Fatalf("expected %d FDs, got %d", wantSize, len(fds.File))
			}
		}
	})
}

// TODO: this test isn't representative of a real app.
// It should probably be removed, as its data is misleading.
func BenchmarkMergedFileDescriptors_Generated(b *testing.B) {
	bcs := []struct {
		globalSize int
		appSize    int
	}{
		{globalSize: 32, appSize: 0},
		{globalSize: 32, appSize: 32},
		{globalSize: 64, appSize: 64},
		{globalSize: 128, appSize: 128},
	}

	for _, bc := range bcs {
		globalSize := bc.globalSize
		appSize := bc.appSize
		wantSize := globalSize + appSize

		b.Run(fmt.Sprintf("%d global, %d app", globalSize, appSize), func(b *testing.B) {
			gf := new(protoregistry.Files)

			for i := 0; i < globalSize; i++ {
				gf.RegisterFile(generateFile(i).UnwrapFile())
			}

			apps := generateAppFiles(appSize, globalSize)

			b.Run("sequential", func(b *testing.B) {
				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					fds, err := proto.MergedFileDescriptors(gf, apps)
					if err != nil {
						b.Fatal(err)
					}

					if len(fds.File) != wantSize {
						b.Fatalf("expected %d FDs, got %d", wantSize, len(fds.File))
					}
				}
			})

			b.Run("concurrent", func(b *testing.B) {
				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					fds, err := proto.ConcurrentMergedFileDescriptors(gf, apps)
					if err != nil {
						b.Fatal(err)
					}

					if len(fds.File) != wantSize {
						b.Fatalf("expected %d FDs, got %d", wantSize, len(fds.File))
					}
				}
			})
		})
	}
}

func generateFile(n int) *desc.FileDescriptor {
	file := builder.NewFile(fmt.Sprintf("/example/foo%d/bar%d.proto", n, n))

	msg := builder.NewMessage(fmt.Sprintf("Msg%d", n)).
		AddField(builder.NewField("id", builder.FieldTypeInt64())).
		AddField(builder.NewField("name", builder.FieldTypeString()))
	file.AddMessage(msg)

	fd, err := file.Build()
	if err != nil {
		panic(err)
	}

	return fd
}

func generateAppFiles(size, offset int) map[string][]byte {
	out := make(map[string][]byte, size)

	buf := new(bytes.Buffer)
	for i := 0; i < size; i++ {
		fd := generateFile(i + offset).AsFileDescriptorProto()

		bz, err := protov2.Marshal(fd)
		if err != nil {
			panic(err)
		}

		buf.Reset()
		gzw := gzip.NewWriter(buf)
		if _, err := gzw.Write(bz); err != nil {
			panic(err)
		}
		if err := gzw.Close(); err != nil {
			panic(err)
		}

		name := strconv.Itoa(i) // Map key doesn't matter for merging the app files.
		out[name] = bytes.Clone(buf.Bytes())
	}

	return out
}
