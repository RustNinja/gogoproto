package benchmany_test

import (
	"bytes"
	"compress/gzip"
	_ "embed"
	"encoding/json"
	"fmt"
	"strconv"
	"testing"

	"github.com/cosmos/gogoproto/proto"
	"github.com/jhump/protoreflect/desc"
	"github.com/jhump/protoreflect/desc/builder"
	protov2 "google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protodesc"
	"google.golang.org/protobuf/reflect/protoregistry"
	"google.golang.org/protobuf/types/descriptorpb"
)

// Generated by manually marshalling from simd:
// 	bz, err := json.Marshal(proto.AllFileDescriptors())
//	if err != nil {
//		panic(err)
//	}
//	if err := os.WriteFile("/tmp/allfd.json", bz, 0600); err != nil {
//		panic(err)
//	}
//
//go:embed testdata/simd-allfd-c4489d.json
var simdAllFDs_c4489d []byte

// Generated by manually marshalling from simd:
// 	var m []*descriptorpb.FileDescriptorProto
//	protoregistry.GlobalFiles.RangeFiles(func(fd protoreflect.FileDescriptor) bool {
//		m = append(m, protodesc.ToFileDescriptorProto(fd))
//		return true
//	})
//
//	bz, err := json.Marshal(m)
//	if err != nil {
//		panic(err)
//	}
//	if err := os.WriteFile("/tmp/globalfd.json", bz, 0600); err != nil {
//		panic(err)
//	}
//go:embed testdata/simd-globalfd-c4489d.json
var simdGlobalFDs_c4489d []byte

// This benchmark uses the file descriptors we extracted from simapp,
// doing some gentle cleanup to account for being in this different go module.
func BenchmarkRepresentativeMergedFileDescriptors(b *testing.B) {
	// The "allFDs" set appears to always be safe to unmarshal.
	var allFDs map[string][]byte
	if err := json.Unmarshal(simdAllFDs_c4489d, &allFDs); err != nil {
		b.Fatal(err)
	}

	// But the global FDs are much more touchy.
	// Some reference files we don't have available in this test package.
	//
	// First we have to unmarshal the raw FD protos.
	var globalFDs []*descriptorpb.FileDescriptorProto
	if err := json.Unmarshal(simdGlobalFDs_c4489d, &globalFDs); err != nil {
		b.Fatal(err)
	}

	// Then we make two passes over what has been deserialized.
	haveGlobal := map[string]struct{}{}
	gf := new(protoregistry.Files)

	// First, add only the files that have no dependencies, as those are safe to add.
	for _, fd := range globalFDs {
		if len(fd.Dependency) > 0 {
			continue
		}

		f, err := protodesc.NewFile(fd, nil) // No resolver for these.
		if err != nil {
			panic(err)
		}
		gf.RegisterFile(f)

		haveGlobal[fd.GetName()] = struct{}{}
	}

	// Now one more pass for those files that do have a dependency.
	// We won't add every single file in this case,
	// but we will add enough for a decent representation of the SDK's protobuf files.
SECONDPASS:
	for _, fd := range globalFDs {
		if len(fd.Dependency) == 0 {
			// Already added this one in the first pass.
			continue
		}
		for _, d := range fd.Dependency {
			_, have := haveGlobal[d]
			if !have {
				continue SECONDPASS
			}
		}

		f, err := protodesc.NewFile(fd, gf) // gf is the "self" resolver.
		if err != nil {
			panic(err)
		}
		gf.RegisterFile(f)
		haveGlobal[f.Path()] = struct{}{}
	}

	// Calculate the expected output size, accounting for expected deduplication.
	wantSize := len(allFDs) + len(haveGlobal)
	for name := range allFDs {
		if _, ok := haveGlobal[name]; ok {
			wantSize--
		}
	}

	b.ResetTimer()

	b.Run("sequential", func(b *testing.B) {
		b.ReportAllocs()

		for i := 0; i < b.N; i++ {
			fds, err := proto.MergedFileDescriptors(gf, allFDs)
			if err != nil {
				b.Fatal(err)
			}

			if len(fds.File) != wantSize {
				b.Fatalf("expected %d FDs, got %d", wantSize, len(fds.File))
			}
		}
	})

	b.Run("concurrent", func(b *testing.B) {
		b.ReportAllocs()

		for i := 0; i < b.N; i++ {
			fds, err := proto.ConcurrentMergedFileDescriptors(gf, allFDs)
			if err != nil {
				b.Fatal(err)
			}

			if len(fds.File) != wantSize {
				b.Fatalf("expected %d FDs, got %d", wantSize, len(fds.File))
			}
		}
	})
}

// TODO: this test isn't representative of a real app.
// It should probably be removed, as its data is misleading.
func BenchmarkMergedFileDescriptors_Generated(b *testing.B) {
	bcs := []struct {
		globalSize int
		appSize    int
	}{
		{globalSize: 32, appSize: 0},
		{globalSize: 32, appSize: 32},
		{globalSize: 64, appSize: 64},
		{globalSize: 128, appSize: 128},
	}

	for _, bc := range bcs {
		globalSize := bc.globalSize
		appSize := bc.appSize
		wantSize := globalSize + appSize

		b.Run(fmt.Sprintf("%d global, %d app", globalSize, appSize), func(b *testing.B) {
			gf := new(protoregistry.Files)

			for i := 0; i < globalSize; i++ {
				gf.RegisterFile(generateFile(i).UnwrapFile())
			}

			apps := generateAppFiles(appSize, globalSize)

			b.Run("sequential", func(b *testing.B) {
				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					fds, err := proto.MergedFileDescriptors(gf, apps)
					if err != nil {
						b.Fatal(err)
					}

					if len(fds.File) != wantSize {
						b.Fatalf("expected %d FDs, got %d", wantSize, len(fds.File))
					}
				}
			})

			b.Run("concurrent", func(b *testing.B) {
				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					fds, err := proto.ConcurrentMergedFileDescriptors(gf, apps)
					if err != nil {
						b.Fatal(err)
					}

					if len(fds.File) != wantSize {
						b.Fatalf("expected %d FDs, got %d", wantSize, len(fds.File))
					}
				}
			})
		})
	}
}

func generateFile(n int) *desc.FileDescriptor {
	file := builder.NewFile(fmt.Sprintf("/example/foo%d/bar%d.proto", n, n))

	msg := builder.NewMessage(fmt.Sprintf("Msg%d", n)).
		AddField(builder.NewField("id", builder.FieldTypeInt64())).
		AddField(builder.NewField("name", builder.FieldTypeString()))
	file.AddMessage(msg)

	fd, err := file.Build()
	if err != nil {
		panic(err)
	}

	return fd
}

func generateAppFiles(size, offset int) map[string][]byte {
	out := make(map[string][]byte, size)

	buf := new(bytes.Buffer)
	for i := 0; i < size; i++ {
		fd := generateFile(i + offset).AsFileDescriptorProto()

		bz, err := protov2.Marshal(fd)
		if err != nil {
			panic(err)
		}

		buf.Reset()
		gzw := gzip.NewWriter(buf)
		if _, err := gzw.Write(bz); err != nil {
			panic(err)
		}
		if err := gzw.Close(); err != nil {
			panic(err)
		}

		name := strconv.Itoa(i) // Map key doesn't matter for merging the app files.
		out[name] = append([]byte(nil), buf.Bytes()...)
	}

	return out
}
